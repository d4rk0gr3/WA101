/***************************************************************************//**
* \file     ADC.c
* \version  1.10
*
* \brief
* Provides the source code to the API for the ADC Component.
*
********************************************************************************
* \copyright
* (c) 2015-2016, Cypress Semiconductor Corporation. All rights reserved.
* This software, including source code, documentation and related
* materials ("Software"), is owned by Cypress Semiconductor
* Corporation ("Cypress") and is protected by and subject to worldwide
* patent protection (United States and foreign), United States copyright
* laws and international treaty provisions. Therefore, you may use this
* Software only as provided in the license agreement accompanying the
* software package from which you obtained this Software ("EULA").
* If no EULA applies, Cypress hereby grants you a personal, nonexclusive,
* non-transferable license to copy, modify, and compile the
* Software source code solely for use in connection with Cypress's
* integrated circuit products. Any reproduction, modification, translation,
* compilation, or representation of this Software except as specified
* above is prohibited without the express written permission of Cypress.
* Disclaimer: THIS SOFTWARE IS PROVIDED AS-IS, WITH NO
* WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING,
* BUT NOT LIMITED TO, NONINFRINGEMENT, IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
* PARTICULAR PURPOSE. Cypress reserves the right to make
* changes to the Software without notice. Cypress does not assume any
* liability arising out of the application or use of the Software or any
* product or circuit described in the Software. Cypress does not
* authorize its products for use in any products where a malfunction or
* failure of the Cypress product may reasonably be expected to result in
* significant property damage, injury or death ("High Risk Product"). By
* including Cypress's product in a High Risk Product, the manufacturer
* of such system or application assumes all risk of such use and in doing
* so agrees to indemnify Cypress against all liability.
*******************************************************************************/
#include "ADC.h"

static int32 ADC_IsChannelSigned(uint32 chan);

uint8 ADC_initVar = 0u; 

uint8 ADC_selected = 0u; /* 0 if no configuration selected. 1 otherwise. */
volatile int16 ADC_offset[ADC_TOTAL_CHANNELS_NUM]; 
volatile int32 ADC_countsPer10Volt[ADC_TOTAL_CHANNELS_NUM]; 

static uint32 ADC_currentConfig = 0u; /* Currently active configuration */
static uint32 ADC_channelEnMasks[ADC_TOTAL_CONFIGS];

/*******************************************************************************
* Local data allocation
*******************************************************************************/
/* Channels configuration generated by customiser */
static const uint32 CYCODE ADC_channelsConfig[] = { 0x00000100UL, 0x00001100UL,  };

/* Filter init */
#if(ADC_ANY_CONFIG_USES_FILTER	!= 0u)	
    #define ADC_UABH_A_FILTER_INITPAIRSSIZE ((ADC_FILTERTYPE_USED == ADC_FILTERTOPOLOGY_LOW_Q) \
                                                         ? 18u \
                                                         : 18u)
    static CyUAB_reg_pair ADC_UABH_A_FILTER_initPairs[ADC_UABH_A_FILTER_INITPAIRSSIZE] =
    {
    	/*OA_CTRL default always first element in initPairs*/
        /* Topology-invariant registers */
         {ADC_UABH_A_OA_CTRL_PTR        , ((uint32)ADC_UABH_A_DEFAULT_OA_CTRL)}
        ,{ADC_UABH_A_SW_STATIC_PTR      , ((uint32)ADC_UABH_A_DEFAULT_SW_STATIC)}
        ,{ADC_UABH_A_SW_MODBIT_SRC_PTR      , ((uint32)ADC_UABH_A_DEFAULT_SW_MODBIT_SRC)}
        ,{ADC_UABH_A_SRAM_CTRL_PTR      , ((uint32)ADC_UABH_A_INVAR_SRAM_CTRL)} 
        ,{ADC_UABH_A_STARTUP_DELAY_PTR  , ((uint32)ADC_UABH_A_INVAR_STARTUP_DELAY)}
        ,{ADC_UABH_A_SW_BOOST_CTRL_PTR  , ((uint32)ADC_UABH_A_DEFAULT_SW_BOOST_CTRL)}
        ,{ADC_UABH_A_SW_OTHER_PTR  , ((uint32)ADC_UABH_A_DEFAULT_SW_OTHER)}
        
        #if (ADC_FILTERTYPE_USED == ADC_FILTERTOPOLOGY_LOW_Q)
            /* Filter-invariant registers */
            ,{ADC_UABH_A_SW_CA_IN0_PTR      , ((uint32)ADC_UABH_A_LOWQSTAT_SW_CA_IN0)}
            ,{ADC_UABH_A_SW_CA_TOP_PTR      , ((uint32)ADC_UABH_A_LOWQSTAT_SW_CA_TOP)}
            ,{ADC_UABH_A_SW_CC_IN0_PTR      , ((uint32)ADC_UABH_A_LOWQSTAT_SW_CC_IN0)}
            ,{ADC_UABH_A_SW_CC_IN1_PTR      , ((uint32)ADC_UABH_A_LOWQSTAT_SW_CC_IN1)}
            ,{ADC_UABH_A_SW_CF_BOT_PTR      , ((uint32)ADC_UABH_A_LOWQSTAT_SW_CF_BOT)}

            /* Parameter-based registers */
            ,{ADC_UABH_A_CAP_CTRL_PTR       , ((uint32)ADC_UABH_A_LOWQDYN_CAP_CTRL)}
            ,{ADC_UABH_A_SW_CB_IN0_PTR      , ((uint32)ADC_UABH_A_LOWQDYN_SW_CB_IN0)}
            ,{ADC_UABH_A_SW_CB_IN1_PTR      , ((uint32)ADC_UABH_A_LOWQDYN_SW_CB_IN1)}
            ,{ADC_UABH_A_SW_CB_TOP_PTR      , ((uint32)ADC_UABH_A_LOWQDYN_SW_CB_TOP)}
            ,{ADC_UABH_A_SW_CC_TOP_PTR      , ((uint32)ADC_UABH_A_LOWQDYN_SW_CC_TOP)}
            ,{ADC_UABH_A_CAP_ABCF_VAL_PTR   , ((uint32)ADC_UABH_A_LOWQDYN_CAP_ABCF_VAL)}
        #elif (ADC_FILTERTYPE_USED == ADC_FILTERTOPOLOGY_HIGH_Q)
            /* Filter-invariant registers */
            ,{ADC_UABH_A_SW_CA_IN0_PTR      , ((uint32)ADC_UABH_A_HIGHQSTAT_SW_CA_IN0)}
            ,{ADC_UABH_A_SW_CA_TOP_PTR      , ((uint32)ADC_UABH_A_HIGHQSTAT_SW_CA_TOP)}
            ,{ADC_UABH_A_SW_CB_IN0_PTR      , ((uint32)ADC_UABH_A_HIGHQSTAT_SW_CB_IN0)}
            ,{ADC_UABH_A_SW_CB_IN1_PTR      , ((uint32)ADC_UABH_A_HIGHQSTAT_SW_CB_IN1)}
            ,{ADC_UABH_A_SW_CC_IN0_PTR      , ((uint32)ADC_UABH_A_HIGHQSTAT_SW_CC_IN0)}
            ,{ADC_UABH_A_SW_CC_IN1_PTR      , ((uint32)ADC_UABH_A_HIGHQSTAT_SW_CC_IN1)}
            ,{ADC_UABH_A_SW_CC_TOP_PTR      , ((uint32)ADC_UABH_A_HIGHQSTAT_SW_CC_TOP)}
            ,{ADC_UABH_A_SW_CF_BOT_PTR      , ((uint32)ADC_UABH_A_HIGHQSTAT_SW_CF_BOT)}

            /* Parameter-based registers */
            ,{ADC_UABH_A_CAP_CTRL_PTR       , ((uint32)ADC_UABH_A_HIGHQDYN_CAP_CTRL)}
            ,{ADC_UABH_A_SW_CB_TOP_PTR      , ((uint32)ADC_UABH_A_HIGHQDYN_SW_CB_TOP)}
            ,{ADC_UABH_A_CAP_ABCF_VAL_PTR   , ((uint32)ADC_UABH_A_HIGHQDYN_CAP_ABCF_VAL)}
        #endif /* (ADC_FILTERTYPE_USED == ADC_FILTERTOPOLOGY_LOW_Q) */
    };

    #define ADC_UABH_B_FILTER_INITPAIRSSIZE ((ADC_FILTERTYPE_USED == ADC_FILTERTOPOLOGY_LOW_Q) \
                                                         ? 19u \
                                                         : 19u)
    static CyUAB_reg_pair ADC_UABH_B_FILTER_initPairs[ADC_UABH_B_FILTER_INITPAIRSSIZE] = 
    {
        /*OA_CTRL default always first element in initPairs*/
        /* Topology-invariant registers */
         {ADC_UABH_B_OA_CTRL_PTR        , ((uint32)ADC_UABH_B_DEFAULT_OA_CTRL)}
        ,{ADC_UABH_B_SW_STATIC_PTR      , ((uint32)ADC_UABH_B_DEFAULT_SW_STATIC)}
        ,{ADC_UABH_B_SW_MODBIT_SRC_PTR      , ((uint32)ADC_UABH_B_DEFAULT_SW_MODBIT_SRC)}
        ,{ADC_UABH_B_SRAM_CTRL_PTR      , ((uint32)ADC_UABH_B_INVAR_SRAM_CTRL)} 
        ,{ADC_UABH_B_STARTUP_DELAY_PTR  , ((uint32)ADC_UABH_B_INVAR_STARTUP_DELAY)}
        ,{ADC_UABH_B_SW_BOOST_CTRL_PTR  , ((uint32)ADC_UABH_B_DEFAULT_SW_BOOST_CTRL)}
        ,{ADC_UABH_B_SW_OTHER_PTR  , ((uint32)ADC_UABH_B_DEFAULT_SW_OTHER)}
        
        #if (ADC_FILTERTYPE_USED == ADC_FILTERTOPOLOGY_LOW_Q)
                	/* Filter-invariant registers */
            ,{ADC_UABH_B_SW_CA_IN0_PTR      , ((uint32)ADC_UABH_B_LOWQSTAT_SW_CA_IN0)}
            ,{ADC_UABH_B_SW_CA_IN1_PTR      , ((uint32)ADC_UABH_B_LOWQSTAT_SW_CA_IN1)}
            ,{ADC_UABH_B_SW_CA_TOP_PTR      , ((uint32)ADC_UABH_B_LOWQSTAT_SW_CA_TOP)}
            ,{ADC_UABH_B_SW_CB_IN0_PTR      , ((uint32)ADC_UABH_B_LOWQSTAT_SW_CB_IN0)}
            ,{ADC_UABH_B_SW_CB_IN1_PTR      , ((uint32)ADC_UABH_B_LOWQSTAT_SW_CB_IN1)}
            ,{ADC_UABH_B_SW_CB_TOP_PTR      , ((uint32)ADC_UABH_B_LOWQSTAT_SW_CB_TOP)}
            ,{ADC_UABH_B_SW_CC_IN0_PTR      , ((uint32)ADC_UABH_B_LOWQSTAT_SW_CC_IN0)}
            ,{ADC_UABH_B_SW_CC_IN1_PTR      , ((uint32)ADC_UABH_B_LOWQSTAT_SW_CC_IN1)}
            ,{ADC_UABH_B_SW_CF_BOT_PTR      , ((uint32)ADC_UABH_B_LOWQSTAT_SW_CF_BOT)}
            
            /* Parameter-based registers */
            ,{ADC_UABH_B_CAP_CTRL_PTR       , ((uint32)ADC_UABH_B_LOWQDYN_CAP_CTRL)}
            ,{ADC_UABH_B_SW_CC_TOP_PTR      , ((uint32)ADC_UABH_B_LOWQDYN_SW_CC_TOP)}
            ,{ADC_UABH_B_CAP_ABCF_VAL_PTR   , ((uint32)ADC_UABH_B_LOWQDYN_CAP_ABCF_VAL)}
        #elif (ADC_FILTERTYPE_USED == ADC_FILTERTOPOLOGY_HIGH_Q)
        	/* Filter-invariant registers */
            ,{ADC_UABH_B_SW_CA_IN0_PTR      , ((uint32)ADC_UABH_B_HIGHQSTAT_SW_CA_IN0)}
            ,{ADC_UABH_B_SW_CA_IN1_PTR      , ((uint32)ADC_UABH_B_HIGHQSTAT_SW_CA_IN1)}
            ,{ADC_UABH_B_SW_CA_TOP_PTR      , ((uint32)ADC_UABH_B_HIGHQSTAT_SW_CA_TOP)}
            ,{ADC_UABH_B_SW_CB_IN0_PTR      , ((uint32)ADC_UABH_B_HIGHQSTAT_SW_CB_IN0)}
            ,{ADC_UABH_B_SW_CB_IN1_PTR      , ((uint32)ADC_UABH_B_HIGHQSTAT_SW_CB_IN1)}
            ,{ADC_UABH_B_SW_CC_IN0_PTR      , ((uint32)ADC_UABH_B_HIGHQSTAT_SW_CC_IN0)}
            ,{ADC_UABH_B_SW_CC_IN1_PTR      , ((uint32)ADC_UABH_B_HIGHQSTAT_SW_CC_IN1)}
            ,{ADC_UABH_B_SW_CF_BOT_PTR      , ((uint32)ADC_UABH_B_HIGHQSTAT_SW_CF_BOT)}
            
            /* Parameter-based registers */
            ,{ADC_UABH_B_CAP_CTRL_PTR       , ((uint32)ADC_UABH_B_HIGHQDYN_CAP_CTRL)}
            ,{ADC_UABH_B_SW_CB_TOP_PTR      , ((uint32)ADC_UABH_B_HIGHQDYN_SW_CB_TOP)}
            ,{ADC_UABH_B_SW_CC_TOP_PTR      , ((uint32)ADC_UABH_B_HIGHQDYN_SW_CC_TOP)}
            ,{ADC_UABH_B_CAP_ABCF_VAL_PTR   , ((uint32)ADC_UABH_B_HIGHQDYN_CAP_ABCF_VAL)}
        #endif /* #if (ADC_FILTERTYPE_USED == ADC_FILTERTOPOLOGY_LOW_Q) */
    };

    static CyUAB_config ADC_UABH_A_FILTER_config = {
        ADC_UABH_A_waveConfig,
        ADC_UABH_A_FILTER_initPairs,
        CyUAB_SHARED_SW_CFG(ADC_UABH_A_PARAM_REF_TIED,ADC_UABH_A_PARAM_AGND_TIED,
            ADC_UABH_A_PARAM_SW_CC,ADC_UABH_A_PARAM_SW_BB,ADC_UABH_A_PARAM_SW_AA),
        ADC_UABH_A_NUM_STEPS,
        (uint8)(ADC_UABH_A_ELEMENT_COUNT(ADC_UABH_A_FILTER_initPairs))
    };

    static CyUAB_config ADC_UABH_B_FILTER_config = {
        ADC_UABH_B_waveConfig,
        ADC_UABH_B_FILTER_initPairs,
        CyUAB_SHARED_SW_CFG(ADC_UABH_B_PARAM_REF_TIED,ADC_UABH_B_PARAM_AGND_TIED,
            ADC_UABH_B_PARAM_SW_CC,ADC_UABH_B_PARAM_SW_BB,ADC_UABH_B_PARAM_SW_AA),
        ADC_UABH_B_NUM_STEPS,
        (uint8)(ADC_UABH_B_ELEMENT_COUNT(ADC_UABH_B_FILTER_initPairs))
    };
#endif /* (ADC_ANY_CONFIG_USES_FILTER	!= 0u)	*/
/*******************************************************************************
* Function Name: ADC_Start
****************************************************************************//**
*
* \brief Performs all required initialization for this component and enables the 
*  power. The power will be set to the appropriate power based on the clock 
*  frequency.
* 
* \param None
* 
* \return None
* 
* \sideeffect None
*
* \globalvars
*  \ref ADC_initVar (RW)
*
* <b>Code Snippet</b>
*  \snippet main.c snippet_ADC_Start
*
*******************************************************************************/
void ADC_Start(void)
{
    if (1u != (1u & ADC_initVar))
    {
        ADC_Init();
        ADC_initVar |= 1u;
    }
    
    ADC_Enable();
    
    return;
}

/*******************************************************************************
* Function Name: ADC_StartEx
****************************************************************************//**
*
* \brief This function starts the ADC and sets the Interrupt 
* Service Routine to the provided address using the 
* ADC_IRQ_StartEx() function. Refer to the Interrupt component 
* datasheet for more information on the ADC_IRQ_StartEx() function.
* 
* \param address This is the address of a user defined function for the ISR.
* 
* \return None
* 
* \sideeffect None
*
* <b>Code Snippet</b>
*  \snippet main.c snippet_ADC_StartEx
*
*******************************************************************************/
void ADC_StartEx(cyisraddress address)
{
    ADC_Start();
    ADC_IRQ_StartEx(address);
    return;
}

/*******************************************************************************
* Function Name: ADC_Stop
****************************************************************************//**
*
* \brief This function stops ADC conversions and puts the ADC into its lowest 
* power mode.
* 
* \param None
* 
* \return None
* 
* \sideeffect
* Do not use the ADC_Stop() API to halt conversions. Instead use the 
* ADC_StopConvert() API. If you use the ADC_Stop() API 
* to halt conversions then later use the ADC_Start() and 
* ADC_StartConvert() APIs to resume conversions, the first channel 
* of the scan may be corrupt. The ADC_StopConvert() API will enable 
* the ADC to complete the current scan of channels. After the 
* channel scan is complete, the ADC will stop all conversions, which 
* can be detected by the use of an ISR or the ADC_IsEndConversion() 
* flag.
*
* <b>Code Snippet</b>
*  \snippet main.c snippet_ADC_Stop
*
*******************************************************************************/
void ADC_Stop(void)
{	
    #if(0u != ADC_ANY_CONFIG_USES_FILTER)	
    	if((ADC_allConfigs[ADC_currentConfig].miscConfig 
    	   & ADC_MISC_CONFIG_FILTER_PRESENT_MSK) 
    	   == ADC_MISC_CONFIG_FILTER_PRESENT_MSK)
    	{
    		ADC_UABH_A_Stop();
    		ADC_UABH_B_Stop();
            ADC_FILTERAGND2SAR_BUFFER_Stop();
    	}
    #endif /* ADC_ANY_CONFIG_USES_FILTER != 0u */
    ADC_SAR_CTRL_REG &= (uint32)~ADC_SAR_CTRL_ENABLED_MSK;
    return;
}

/* ****************************************************************************
* Function Name: ADC_InitConfig
****************************************************************************//*
*
* \brief Configures all of the registers for a given configuration for scanning.
*
* \param scan Number of scan defined in the ADC.
*
* \return None
*
* \sideeffect None
*
* <b>Code Snippet</b>
*  \snippet main.c snippet_ADC_InitConfig
*
*******************************************************************************/
void ADC_InitConfig(const ADC_CONFIG_STRUCT *config)
{
	uint32 chNum;
    uint32 tmpRegVal;
	
    #if(0u != ADC_ANY_CONFIG_USES_FILTER)	        
    	if((config->miscConfig & ADC_MISC_CONFIG_FILTER_PRESENT_MSK) 
    	    == ADC_MISC_CONFIG_FILTER_PRESENT_MSK)
    	{
            ADC_intUabClock_SetFractionalDividerRegister(config->filterClkDivider, 0u);    		
    	}
    #endif /* ADC_ANY_CONFIG_USES_FILTER != 0u */
    #if (ADC_CLOCK_INTERNAL)
        ADC_intSarClock_SetFractionalDividerRegister(config->clkDivider, 0u);
        
    #endif /* ADC_CLOCK_INTERNAL */
    /* Init SAR and MUX registers */
	ADC_SAR_CTRL_REG |= config->ctrl
   
	/* Enable the SAR internal pump when global pump is enabled */
    | (((ADC_PUMP_CTRL_REG & ADC_PUMP_CTRL_ENABLED) != 0u) 
    ? ADC_SAR_CTRL_BOOSTPUMP_EN_MSK : 0u);
	
	ADC_SAR_SAMPLE_CTRL_REG = config->sampleCtrl;
	ADC_SAR_RANGE_THRES_REG = config->rangeThres;	
	ADC_SAR_RANGE_COND_REG = config->rangeCond;
	ADC_SAR_SAMPLE_TIME01_REG = config->sampleTime01;
	ADC_SAR_SAMPLE_TIME23_REG = config->sampleTime23;
    
	/* Connect Vminus to VSSA when even one channel is single-ended or multiple channels configured */
	if(1u == ADC_MUX_SWITCH0_INIT)
	{
		ADC_MUX_SWITCH0_REG |= ADC_MUX_FW_VSSA_VMINUS;
		/* Set MUX_HW_CTRL_VSSA in MUX_SWITCH_HW_CTRL when multiple channels enabled */
		if(1ul < config->numChannels)
		{
			ADC_MUX_SWITCH_HW_CTRL_REG |= ADC_MUX_FW_VSSA_VMINUS;
		}
	}
    
	/* Clear and set interrupt masks */
	ADC_SAR_SATURATE_INTR_MASK_REG = 0u;
    ADC_SAR_RANGE_INTR_MASK_REG = 0u;	
	ADC_SAR_SATURATE_INTR_MASK_REG = config->satIntMask;
	ADC_SAR_RANGE_INTR_MASK_REG = config->rangeIntMask;
	ADC_SAR_INTR_MASK_REG = ADC_EOS_MASK;
    
	/* Double the non-overlap delay and latch enable time when using */
    /* internal reference without bypass cap */
    tmpRegVal = ADC_SAR_DFT_CTRL_REG;
	if(((config->ctrl & ADC__SAR_CTRL_VREF_BYP_AND_SEL_MSK) 
	    == ADC__INTERNAL1024) 
	    || ((config->ctrl & ADC__SAR_CTRL_VREF_BYP_AND_SEL_MSK) 
	    == ADC__INTERNALVREF))
	{
        tmpRegVal &= ~ADC_SAR_DFT_CTRL_DCEN_MSK;
		tmpRegVal |= ADC_SAR_DFT_CTRL_DLY_INC_MSK;
	}
	else
	{
		tmpRegVal |= ADC_SAR_DFT_CTRL_DCEN_MSK;
        tmpRegVal &= (uint32)~ADC_SAR_DFT_CTRL_DLY_INC_MSK;
	}	
	ADC_SAR_DFT_CTRL_REG = tmpRegVal;
	
	for(chNum = 0u; chNum < config->numChannels; chNum++)
    {
		tmpRegVal = (ADC_channelsConfig[config->channelBase + chNum] 
		& ADC_CHANNEL_CONFIG_MASK);
        
        #if(ADC_TOTAL_CHANNELS_NUM > 1)
            tmpRegVal |= ADC_InputsPlacement[config->channelBase + chNum];
            /*Non-paired differential channels set NEG_ADDR_EN and clear DIFFERENTIAL_EN */
            if(0u != (ADC_InputsPlacement[config->channelBase + chNum] & ADC_CHANNEL_CONFIG_NEG_ADDR_EN_MSK))
            {
                tmpRegVal &= ~ADC_SAR_CHAN_CONFIG_DIFFERENTIAL_EN_MSK;
            }
        #endif
        
		CY_SET_REG32((reg32 *)(ADC_SAR_CHAN_CONFIG_IND + (uint32)(chNum << 2)), tmpRegVal);
	}
	
    return;
}

/* ****************************************************************************
* Function Name: ADC_SelectConfig
****************************************************************************//* 
*
* \brief Selects the predefined configuration for scanning. Disables
* and re-enables the SAR and filter (if filter used).
* 
* \param config Number of configuration  in the ADC.
* 
* \param restart Determines if the ADC should be  restarted after 
* selecting the configuration.
*
* \sideeffect Calls ADC_Init() to initialize 
* ADC_channelEnMasks[]
*
* <b>Code Snippet</b>
*  \snippet main.c snippet_ADC_SelectConfig
*
*******************************************************************************/
void ADC_SelectConfig(uint32 config, uint32 restart)
{
    /* Check whether the configuration number is valid or not */
    if(ADC_TOTAL_CONFIGS > config)
    {
        /* Stop the ADC before changing configurations */
	    ADC_Stop();
        ADC_selected = 1u;
        
    	if(0u == ADC_initVar)
    	{
            ADC_Init();
    	}
        #if (ADC_VREF_ROUTED)
        ADC_vrefAMux_Select((uint8)config);
        #endif
    	ADC_InitConfig(&ADC_allConfigs[config]);
        #if(0u != ADC_ANY_CONFIG_USES_FILTER)
        ADC_filterVinMux_Select((uint8)config);
        #endif
    	ADC_SAR_CHAN_EN_REG = ADC_channelEnMasks[config];
    	ADC_currentConfig = config;
        
        if(1u == restart)
        {
            /* Restart the ADC */    
            ADC_Start();
            
            /* Restart the scan */
            ADC_StartConvert();
        }
    }
    return;
}

/*******************************************************************************
* Function Name: ADC_StartConvert
****************************************************************************//**
*
* \brief In continuous mode, this API starts the conversion process and it runs 
* continuously. 

* In Single Shot mode, the function triggers a single scan and 
* every scan requires a call of this function. The mode is set with the 
* Sample Mode parameter in the customizer. The customizer setting can be 
* overridden at run time with the ADC_SetConvertMode() function.
* 
* \param None
* 
* \return None
* 
* \sideeffect None
*
* <b>Code Snippet</b>
*  \snippet main.c snippet_ADC_StartConvert
*
*******************************************************************************/
void ADC_StartConvert(void)
{
	/* Freerunning mode */
	if((ADC_SAR_SAMPLE_CTRL_REG 
		& ADC_SAR_SAMPLE_CTRL_DSI_TRIGGER_LEVEL_MSK) 
		== ADC_SAR_SAMPLE_CTRL_DSI_TRIGGER_LEVEL_MSK)
    {
		ADC_SAR_SAMPLE_CTRL_REG |= ADC_SAR_SAMPLE_CTRL_CONTINUOUS_MSK ; 
        #if (ADC_ANY_CONFIG_USES_FILTER)
            if (0u == (ADC_initVar & 0x2u))
            {
                ADC_initVar |= 0x2u;
                ADC_TrimOffset();
            }
        #endif /* (ADC_ANY_CONFIG_USES_FILTER && (CFG0_FILTER_TYPE == LOW_PASS)) */
	}
	else /* Firmware trigger */
	{
		ADC_SAR_START_CTRL_REG = ADC_SAR_START_CTRL_FW_TRIGGER_MSK;
	}
    
    return;
}

/*******************************************************************************
* Function Name: ADC_StopConvert
****************************************************************************//**
*
* \brief Forces the ADC to stop conversions. If a conversion is 
* currently executing, that conversion will complete, but no further conversions 
* will occur.
* 
* \param None
*
* \return None
*
* \sideeffect None
*
* <b>Code Snippet</b>
*  \snippet main.c snippet_ADC_StopConvert
*
*******************************************************************************/
void ADC_StopConvert(void)
{
    if((ADC_SAR_SAMPLE_CTRL_REG  
		& ADC_SAR_SAMPLE_CTRL_DSI_TRIGGER_LEVEL_MSK) 
		== ADC_SAR_SAMPLE_CTRL_DSI_TRIGGER_LEVEL_MSK)
	{
        ADC_SAR_SAMPLE_CTRL_REG &= ~ADC_SAR_SAMPLE_CTRL_CONTINUOUS_MSK;
        
        if((ADC_allConfigs[ADC_currentConfig].miscConfig 
            & ADC_MISC_CONFIG_FILTER_PRESENT_MSK) 
    	    == ADC_MISC_CONFIG_FILTER_PRESENT_MSK)
        {
            /* Re-synchronize the Filter if a filter is present */
            ADC_Stop();
            ADC_Start();
        }
	}
    
    return;
}
/*******************************************************************************
* Function Name: ADC_SetConvertMode
****************************************************************************//**
*
* \brief Sets the conversion mode to either Single-Shot or continuous. This 
* function overrides the settings applied in the customizer. Changing 
* configurations will restore the values set in the customizer.
*
* \param mode Sets the conversion mode. See table below for details.
* | Options                          | Description                             |
* | :------------------------------- | :-------------------------------------- |
* | ADC_SINGLE_SHOT     | Calling the ADC_StartConvert() function after setting mode this will trigger a single scan. Sets the SOC signal to be edge sensitive, each edge will trigger a single scan. |
* | ADC_CONTINUOUS      | Calling the ADC_StartConvert() function after setting this mode trigger continuous scanning. This mode sets the SOC signal to be level sensitive. The ADC will continuously scan while soc is active. |
*
* \return None
* 
* \sideeffect None
*
* <b>Code Snippet</b>
*  \snippet main.c snippet_ADC_SetConvertMode
*
*******************************************************************************/
void ADC_SetConvertMode(uint32 mode)
{
    if(ADC_CONTINUOUS == mode)
    {
        ADC_SAR_SAMPLE_CTRL_REG |= ADC_SAR_SAMPLE_CTRL_DSI_TRIGGER_LEVEL_MSK;       
    }
    else
    {
        ADC_SAR_SAMPLE_CTRL_REG &= ~ADC_SAR_SAMPLE_CTRL_DSI_TRIGGER_LEVEL_MSK;       
    }
}
/* ****************************************************************************
* Function Name: ADC_IRQ_Enable
****************************************************************************//*
*
* \brief Enables interrupts to occur at the end of a conversion. Global 
* interrupts must also be enabled for the ADC interrupts to occur.
*
* \param None
*
* \return None
*
* \sideeffect None
*
* <b>Code Snippet</b>
*  \snippet main.c snippet_ADC_IRQ_Enable
*
*******************************************************************************/


/* ****************************************************************************
* Function Name: ADC_IRQ_Disable
****************************************************************************//* 
*
* \brief Disables end of conversion interrupts. 
*
* \param None
* 
* \return None
* 
* \sideeffect None
*
* <b>Code Snippet</b>
*  \snippet main.c snippet_ADC_IRQ_Disable
*
*******************************************************************************/


/*******************************************************************************
* Function Name: ADC_SetEosMask
****************************************************************************//**
*
* \brief Sets of clears the End of Scan (EOS) interrupt mask. 
*
* \param mask 1 to set the mask, 0 to clear the mask.
*
* \return None
* 
* \sideeffect All other bits in the INTR register are cleared by this function.
*
* <b>Code Snippet</b>
*  \snippet main.c snippet_ADC_SetEosMask
*
*******************************************************************************/
void ADC_SetEosMask(uint32 mask)
{
    ADC_SAR_INTR_MASK_REG = mask & ADC_EOS_MASK;
    
    return;
}

/* ****************************************************************************
* Function Name: ADC_SetChanMask
****************************************************************************//*
*
* \brief Sets enable/disable mask for all channels.
*
*
* \param chanMask
*  Channel mask.
*
* \sideeffect
*  None.
*
* <b>Code Snippet</b>
*  \snippet main.c snippet_ADC_SetChanMask
*
*******************************************************************************/
void ADC_SetChanMask(uint32 chanMask)
{
    ADC_SAR_CHAN_EN_REG = chanMask & ADC_MAX_CHANNELS_EN_MASK;
    ADC_channelEnMasks[ADC_currentConfig] = chanMask & ADC_MAX_CHANNELS_EN_MASK;
    return;
}

/*******************************************************************************
* Function Name: ADC_IsEndConversion
****************************************************************************//**
*
* \brief Immediately returns the status of the conversion or does not return 
* (blocking) until the conversion completes, depending on the retMode parameter.
*
* \param retMode Check conversion return mode. See the following table for 
* options.
* | Options                              | Description                             |
* | :-------------------------------     | :-------------------------------------- |
* | ADC_RETURN_STATUS       | Immediately returns the conversion status for sequential channels. If the value returned is zero, the conversion is not complete, and this function should be retried until a nonzero result is returned. |
* | ADC_WAIT_FOR_RESULT     | Does not return a result until the ADC conversion of all sequential channels is complete. |
* | ADC_RETURN_STATUS_INJ   | Immediately returns the conversion status for the injection channel. If the value returned is zero, the conversion is not complete, and this function should be retried until a nonzero result is returned. |
* | ADC_WAIT_FOR_RESULT_INJ | Does not return a result until the ADC completes injection channel conversion. |
* 
* \return uint8: If a nonzero value is returned, the last conversion is complete. 
* If the returned value is zero, the ADC is still calculating the last result.
*
* \sideeffect This function reads the end of conversion status, and clears it afterward.
* 
* <b>Code Snippet</b>
*  \snippet main.c snippet_ADC_IsEndConversion
*
*******************************************************************************/
uint32 ADC_IsEndConversion(uint32 retMode)
{
    uint32 endOfConversion = 0u;
    uint32 wdt = 0x3FFFFFFuL; /* Watchdog timer for blocking while loop */
    if((ADC_RETURN_STATUS == retMode) || (ADC_WAIT_FOR_RESULT == retMode))
    {
        do
        {
            endOfConversion = ADC_SAR_INTR_REG & ADC_EOS_MASK;
            wdt--;
        }while(((0u == endOfConversion) 
            && (((uint32) retMode & ADC_WAIT_FOR_RESULT) != 0u))
            && (0uL != wdt));

        if(0u != endOfConversion)
        {
            /* Clear EOS bit */
            ADC_SAR_INTR_REG = ADC_EOS_MASK;
        }
    }
    
    return endOfConversion;
}
 
/* ****************************************************************************
* Function Name: ADC_IsChannelSigned(uint32 chan)
****************************************************************************//*
*
* Determines if the provided channel is in signed format. 
*
* \param chan The ADC channel to check. 
*
* \return None
* 
* \sideeffect None
*
*
*******************************************************************************/
static int32 ADC_IsChannelSigned(uint32 chan)
{
    int32 isSigned = 0;
    uint32 chanConfig;
    
    chanConfig = CY_GET_REG32((reg32 *)(ADC_SAR_CHAN_CONFIG_IND + (uint32)(chan << 2u)));
    /* If differential mode */
    if(0u != (chanConfig & ADC_CHANNEL_CONFIG_DIFF_ALL_MSK))
    {
        /*If signed differential */
        if((ADC_allConfigs[ADC_currentConfig].sampleCtrl 
            & ADC_SAR_SAMPLE_CTRL_DIFFERENTIAL_SIGNED_MSK) != 0u)
        {
            isSigned = 1;
        }
    }
    else
    {
        if((ADC_allConfigs[ADC_currentConfig].sampleCtrl
            & ADC_SAR_SAMPLE_CTRL_SINGLE_ENDED_SIGNED_MSK) != 0u)
        {
            isSigned = 1;
        }
    }
    return isSigned;
}
/*******************************************************************************
* Function Name: ADC_GetResult16
****************************************************************************//**
*
* \brief Gets the data available in the channel result data register
*
* \param chan The ADC channel to read the result from. The first 
* channel is 0 and the injection channel if enabled is the number of valid 
* channels.
*
* \return Returns converted data as a signed 16-bit integer.
* 
* \sideeffect None
* 
* <b>Code Snippet</b>
*  \snippet main.c snippet_ADC_GetResult16
*
*******************************************************************************/
int16 ADC_GetResult16(uint32 chan)
{
    uint32 adcResult;
    
    /* Halt CPU in debug mode if channel is out of valid range */
    CYASSERT(chan < ADC_TOTAL_CHANNELS_NUM);

    if(ADC_TOTAL_CHANNELS_NUM > chan)
    {   
        adcResult = CY_GET_REG32((reg32 *)(ADC_SAR_CHAN_RESULT_IND + (uint32)(chan << 2u))) &
            ADC_RESULT_MASK; 
    }
    else
    {
		adcResult = 0u;
    }
    
    return (int16) adcResult;
}

/*******************************************************************************
* Function Name: ADC_GetResult32
****************************************************************************//**
*
* \brief Gets the data available in the channel result data register. 
*
* \param chan The ADC channel to read the result from. The first 
* channel is 0 and the injection channel if enabled is the number of valid 
* channels.
*
* \return Returns converted data as a signed 32-bit integer.
* 
* \sideeffect None
*
* <b>Code Snippet</b>
*  \snippet main.c snippet_ADC_GetResult32
*
*******************************************************************************/
int32 ADC_GetResult32(uint32 chan)
{
    uint32 adcResult;
    int16 adcResult16;
    int32 finalResult;
    
    /* Halt CPU in debug mode if channel is out of valid range */
    CYASSERT(chan < ADC_TOTAL_CHANNELS_NUM);

    if(ADC_TOTAL_CHANNELS_NUM > chan)
    {
        adcResult = CY_GET_REG32((reg32 *)(ADC_SAR_CHAN_RESULT_IND + (uint32)(chan << 2u))) &
            ADC_RESULT_MASK;
    }
    else
    {
        adcResult = 0u;
    }
    /* Sign extend if channel is signed format */
    if(ADC_IsChannelSigned(chan) == 1)
    {
        adcResult16 = (int16) adcResult;
        finalResult = (int32) adcResult16;
    }
    else
    {
        finalResult = (int32) adcResult;
    }
    return finalResult;
}

/*******************************************************************************
* Function Name: ADC_SetLowLimit
****************************************************************************//**
*
* \brief Sets the low limit parameter for a limit condition.
*
* \param lowLimit The low limit for a limit condition.
*
* \return None
* 
* \sideeffect None
*
* <b>Code Snippet</b>
*  \snippet main.c snippet_ADC_SetLowLimit
*
*******************************************************************************/
void ADC_SetLowLimit(uint32 lowLimit)
{   
    ADC_SAR_RANGE_THRES_REG &= ~(uint32)(ADC_SAR_RANGE_THRES_RANGE_LOW_MSK);
    ADC_SAR_RANGE_THRES_REG |= lowLimit & ADC_SAR_RANGE_THRES_RANGE_LOW_MSK;
    return;
}

/*******************************************************************************
* Function Name: ADC_SetHighLimit
****************************************************************************//**
*
* \brief Sets the high limit parameter for a limit condition.
*
* \param highLimit The high limit for a limit condition.
*
* \return None
* 
* \sideeffect None
* 
* <b>Code Snippet</b>
*  \snippet main.c snippet_ADC_SetHighLimit
*
*******************************************************************************/
void ADC_SetHighLimit(uint32 highLimit)
{   
    ADC_SAR_RANGE_THRES_REG &= ~(uint32)(ADC_SAR_RANGE_THRES_RANGE_HIGH_MSK);
    ADC_SAR_RANGE_THRES_REG |= (uint32)(highLimit << ADC_SAR_RANGE_THRES_RANGE_HIGH_SHFT);
    return;
}

/*******************************************************************************
* Function Name: ADC_SetLimitMask
****************************************************************************//**
*
* \brief Sets the channel limit condition mask.
*
*
* \param mask Sets which channels that may cause a limit condition interrupt. 
* Setting bits for channels that do not exist will have no effect. For example, 
* if only 6  channels were enabled, setting a mask of 0x0103 would only enable 
* the last two channels (0 and 1).
*
* \return None
* 
* \sideeffect None
*
* <b>Code Snippet</b>
*  \snippet main.c snippet_ADC_SetLimitMask
*
*******************************************************************************/
void ADC_SetLimitMask(uint32 mask)
{   
    ADC_SAR_RANGE_INTR_MASK_REG = mask & ADC_MAX_CHANNELS_EN_MASK;
 
    return;
}

/*******************************************************************************
* Function Name: ADC_SetSatMask
****************************************************************************//**
*
* \brief Sets the channel saturation event mask.
*
* \param mask Sets which channels that may cause a saturation event interrupt. 
* Setting bits for channels that do not exist will have no effect. For example, 
* if only 8 channels were enabled, setting a mask of 0x01C0 would only enable two 
* channels (6 and 7).
*
* \return None
* 
* \sideeffect None
*
* <b>Code Snippet</b>
*  \snippet main.c snippet_ADC_SetSatMask
*
*******************************************************************************/
void ADC_SetSatMask(uint32 mask)
{   
    ADC_SAR_SATURATE_INTR_MASK_REG = mask & ADC_MAX_CHANNELS_EN_MASK;    
    return;
}

/*******************************************************************************
* Function Name: ADC_SetOffset
****************************************************************************//**
*
* \brief Sets the ADC offset which is used by the functions 
* ADC_CountsTo_uVolts, ADC_CountsTo_mVolts and 
* ADC_CountsTo_Volts to subtract the offset from the given reading 
* before calculating the voltage conversion.
*
* \param chan ADC channel number. 
* 
* \param offset This value is a measured value when the inputs are shorted or 
* connected to the same input voltage.
*
* \return None
* 
* \sideeffect None
*
* <b>Code Snippet</b>
*  \snippet main.c snippet_ADC_SetOffset
*
*******************************************************************************/
void ADC_SetOffset(uint32 chan, int16 offset)
{   
    /* Halt CPU in debug mode if channel is out of valid range */
    CYASSERT(chan < ADC_TOTAL_CHANNELS_NUM);

    ADC_offset[ADC_allConfigs[ADC_currentConfig].channelBase + chan] = offset;
    return;
}

/*******************************************************************************
* Function Name: ADC_SetGain
****************************************************************************//**
*
* \brief Sets the ADC gain in counts per 10 volt for the voltage 
* conversion functions below. This value is set by default by the reference and 
* input range settings. It should only be used to further calibrate the 
* ADC with a known input or if an external reference is used. 
* Affects the ADC_CountsTo_uVolts, ADC_CountsTo_mVolts 
* and ADC_CountsTo_Volts functions by supplying the correct 
* conversion between ADC counts and voltage.
* 
* \param chan ADC channel number.
* 
* \param adcGain ADC gain in counts per 10 volt.
*
* \return None
* 
* \sideeffect None
*
* <b>Code Snippet</b>
*  \snippet main.c snippet_ADC_SetGain
*
*******************************************************************************/
void ADC_SetGain(uint32 chan, int32 adcGain)
{   
    /* Halt CPU in debug mode if channel is out of valid range */
    CYASSERT(chan < ADC_TOTAL_CHANNELS_NUM);

    ADC_countsPer10Volt[ADC_allConfigs[ADC_currentConfig].channelBase + chan]
	= adcGain;
    return;
}

/*******************************************************************************
* Function Name: ADC_CountsTo_Volts
****************************************************************************//**
*
* \brief Converts the ADC output to Volts as a floating point number. For 
* example, if the ADC measured 0.534 volts, the return value would be 0.534. The 
* calculation of voltage depends on the value of the voltage reference. When the 
* Vref is based on Vdda, the value used for Vdda is set for the project in the 
* System tab of the DWR.
*
* \param chan ADC channel number.   
*
* \param adcCounts Result from the ADC conversion.
*
* \return Result in Volts.
* 
* \sideeffect None
*
* <b>Code Snippet</b>
*  \snippet main.c snippet_ADC_CountsTo_Volts
*
*******************************************************************************/
float32 ADC_CountsTo_Volts(uint32 chan, int16 adcCounts)
{   
    float32 result_Volts = 0.0f;
	uint32 temp;
	uint32 averageAdcSamplesDiv;
	uint32 rawChannel;
	rawChannel = ADC_allConfigs[ADC_currentConfig].channelBase + chan;
	
	if((ADC_allConfigs[ADC_currentConfig].sampleCtrl 
		& ADC_SAR_SAMPLE_CTRL_LEFT_ALIGN_MSK) 
		!= ADC_SAR_SAMPLE_CTRL_LEFT_ALIGN_MSK)
	{
        /* Halt CPU in debug mode if channel is out of valid range */
        CYASSERT(chan < ADC_TOTAL_CHANNELS_NUM);

        /* Divide the adcCount when accumulate averaging mode selected */
		if((ADC_allConfigs[ADC_currentConfig].sampleCtrl 
			& ADC_SAR_SAMPLE_CTRL_AVG_SHIFT_MSK) 
			!= ADC_SAR_SAMPLE_CTRL_AVG_SHIFT_MSK)
		{
            if((ADC_channelsConfig[rawChannel] & ADC_SAR_CHAN_CONFIG_AVG_EN_MSK) != 0u)
            {
                /* Divide by 2^(AVG_CNT + 1) */
				averageAdcSamplesDiv = ((ADC_allConfigs[ADC_currentConfig].sampleCtrl 
					& ADC_SAR_SAMPLE_CTRL_AVG_CNT_MSK) 
					>> ADC_SAR_SAMPLE_CTRL_AVG_CNT_SHFT);
                averageAdcSamplesDiv = (1uL << (averageAdcSamplesDiv + 1uL));
                
                /* If unsigned format, prevent sign extension */
                if(0 == ADC_IsChannelSigned(chan))
                {
					temp = ((uint16) adcCounts / averageAdcSamplesDiv);
                    adcCounts = (int16) temp;
                }
                else
                {
                    adcCounts /= (int16) averageAdcSamplesDiv;
                }
            }
		}
        /* Subtract ADC offset */
        adcCounts -= ADC_offset[rawChannel];

        result_Volts = ((float32)adcCounts * ADC_10V_COUNTS) 
			/ (float32)ADC_countsPer10Volt[rawChannel];
	}
	return result_Volts;
}

/*******************************************************************************
* Function Name: ADC_CountsTo_mVolts
****************************************************************************//**
*
* \brief Converts the ADC output to millivolts as a 16-bit integer. 
* For example, if the ADC measured 0.534 volts, the return value 
* would be 534. The calculation of voltage depends on the value of the voltage 
* reference. When the Vref is based on Vdda, the value used for Vdda is set for 
* the project in the System tab of the DWR.
*
* \param chan ADC channel number. 
*
* \param adcCounts Result from the ADC conversion.
* 
* \return Result in mV.
* 
* \sideeffect None.
*
* <b>Code Snippet</b>
*  \snippet main.c snippet_ADC_CountsTo_mVolts
*
*******************************************************************************/
int16 ADC_CountsTo_mVolts(uint32 chan, int16 adcCounts)
{   
    int16 result_mVolts = 0;
	uint32 temp;
	uint32 averageAdcSamplesDiv;
	uint32 rawChannel;
    
	rawChannel = ADC_allConfigs[ADC_currentConfig].channelBase + chan;
	
	if((ADC_allConfigs[ADC_currentConfig].sampleCtrl 
		& ADC_SAR_SAMPLE_CTRL_LEFT_ALIGN_MSK) 
		!= ADC_SAR_SAMPLE_CTRL_LEFT_ALIGN_MSK)
	{
		/* Halt CPU in debug mode if channel is out of valid range */
	    CYASSERT(chan < ADC_TOTAL_CHANNELS_NUM);

	    /* Divide the adcCount when accumulate averaging mode selected */
		if((ADC_allConfigs[ADC_currentConfig].sampleCtrl 
			& ADC_SAR_SAMPLE_CTRL_AVG_SHIFT_MSK) 
			!= ADC_SAR_SAMPLE_CTRL_AVG_SHIFT_MSK)
		{
	        if((ADC_channelsConfig[rawChannel] 
				& ADC_SAR_CHAN_CONFIG_AVG_EN_MSK) != 0u)
	        {
                /* Divide by 2^(AVG_CNT + 1) */
	            averageAdcSamplesDiv = ((ADC_allConfigs[ADC_currentConfig].sampleCtrl 
					& ADC_SAR_SAMPLE_CTRL_AVG_CNT_MSK) 
					>> ADC_SAR_SAMPLE_CTRL_AVG_CNT_SHFT);
                averageAdcSamplesDiv = (1uL << (averageAdcSamplesDiv + 1uL));
                
                /* If unsigned format, prevent sign extension */
                if(0 == ADC_IsChannelSigned(chan))
                {
					temp = ((uint16) adcCounts / averageAdcSamplesDiv);
                    adcCounts = (int16) temp;
                }
                else
                {
                    adcCounts /= (int16) averageAdcSamplesDiv;
                }
	        }
	    }

	    /* Subtract ADC offset */
	    adcCounts -= ADC_offset[rawChannel];

	    result_mVolts = (int16)((((int32)adcCounts * ADC_10MV_COUNTS) + ( (adcCounts > 0) ? 
	             (ADC_countsPer10Volt[rawChannel] / 2) 
				: (-(ADC_countsPer10Volt[rawChannel] / 2)) )) 
	             / ADC_countsPer10Volt[rawChannel]);
	}
    return result_mVolts;
}

/*******************************************************************************
* Function Name: ADC_CountsTo_uVolts
****************************************************************************//**
*
* \brief Converts the ADC output to microvolts as a 32-bit integer. 
* For example, if the ADC measured 0.534 volts, the return value 
* would be 534000. The calculation of voltage depends on the value of the voltage 
* reference. When the Vref is based on Vdda, the value used for Vdda is set for 
* the project in the System tab of the DWR.
*
* \param chan ADC channel number.   
*
* \param adcCounts Result from the ADC conversion.
*
* \return Result in microvolts.
* 
* \sideeffect None
*
* <b>Code Snippet</b>
*  \snippet main.c snippet_ADC_CountsTo_uVolts
*
*******************************************************************************/
int32 ADC_CountsTo_uVolts(uint32 chan, int16 adcCounts)
{   
    int64 result_uVolts = 0;
	uint32 temp;
	uint32 averageAdcSamplesDiv;
	uint32 rawChannel;
	rawChannel = ADC_allConfigs[ADC_currentConfig].channelBase + chan;

	if((ADC_allConfigs[ADC_currentConfig].sampleCtrl 
		& ADC_SAR_SAMPLE_CTRL_LEFT_ALIGN_MSK) 
		!= ADC_SAR_SAMPLE_CTRL_LEFT_ALIGN_MSK)
	{
        /* Halt CPU in debug mode if channel is out of valid range */
        CYASSERT(chan < ADC_TOTAL_CHANNELS_NUM);

        /* Divide the adcCount when accumulate averaging mode selected */
		if((ADC_allConfigs[ADC_currentConfig].sampleCtrl 
			& ADC_SAR_SAMPLE_CTRL_AVG_SHIFT_MSK) 
			!= ADC_SAR_SAMPLE_CTRL_AVG_SHIFT_MSK)
		{
	        if((ADC_channelsConfig[rawChannel] & ADC_SAR_CHAN_CONFIG_AVG_EN_MSK) != 0u)
	        {
                /* Divide by 2^(AVG_CNT + 1) */
				averageAdcSamplesDiv = ((ADC_allConfigs[ADC_currentConfig].sampleCtrl 
					& ADC_SAR_SAMPLE_CTRL_AVG_CNT_MSK) 
					>> ADC_SAR_SAMPLE_CTRL_AVG_CNT_SHFT);
                averageAdcSamplesDiv = (1uL << (averageAdcSamplesDiv + 1uL));
                
                /* If unsigned format, prevent sign extension */
                if(0 == ADC_IsChannelSigned(chan))
                {
					temp = ((uint16) adcCounts / averageAdcSamplesDiv);
                    adcCounts = (int16) temp;
                }
                else
                {
                    adcCounts /= (int16) averageAdcSamplesDiv;
                }
            }
        }

        /* Subtract ADC offset */
        adcCounts -= ADC_offset[rawChannel];

        result_uVolts = ((int64)adcCounts * ADC_10UV_COUNTS) 
			/ ADC_countsPer10Volt[rawChannel];
	}
	return ( (int32)result_uVolts );
}

#if(0u != ADC_ANY_CONFIG_USES_FILTER)		
    /* ****************************************************************************
    * Function Name: ADC_TrimOffset
    ****************************************************************************//*
    *
    * \brief Runs an algorithm to reduce offset using the UAB's opamp trim.
    *
    * \param None
    * 
    * \return None
    *
    * \sideeffect None
    *
    * <b>Code Snippet</b>
    *  \snippet main.c snippet_ADC_TrimOffset
    *
    *******************************************************************************/
    void ADC_TrimOffset(void)
    {
        uint32 curTrim = 0uL;
        uint32 bestTrim = 0uL;
        int16 curResult = 0;
        int16 bestResult = (int16)0x7fff; /* Max positive 16-bit number */
        int16 targResult = 0;

        ADC_Stop();
        ADC_Start();
        ADC_StartConvert();
        /* Set firmware modbit. */
        ADC_UABH_A_CAP_ABCF_VAL_REG |= (0x1uL << CyUAB_SIGN_VAL_SHIFT);
        ADC_UABH_B_CAP_ABCF_VAL_REG |= (0x1uL << CyUAB_SIGN_VAL_SHIFT);
        /* Unsigned mode zero is 0x800, signed mode zero is 0 */
        targResult = (0u != (ADC_SAR_SAMPLE_CTRL_REG 
                                 & ADC_SAR_SAMPLE_CTRL_DIFFERENTIAL_SIGNED_MSK))
                           ? 0
                           : (int16)0x0800;
                        
        /* Check each trim value. Remember trim that created smallest offset.*/
        for(curTrim = 0uL; curTrim < 0x10uL; curTrim++)
        {
            /* Use defines from cydevice_trm to set trim. */
            CY_SET_REG32(CYREG_UAB0_OA_TRIM0, 
                CY_GET_REG32(CYREG_UAB0_OA_TRIM0) & ~(0xfuL << CyUAB_OA_OFFSET_SHIFT));
            CY_SET_REG32(CYREG_UAB0_OA_TRIM0, 
                CY_GET_REG32(CYREG_UAB0_OA_TRIM0) | (curTrim << CyUAB_OA_OFFSET_SHIFT));
            CyDelayUs(100u);
            (void)ADC_IsEndConversion(ADC_WAIT_FOR_RESULT);
            curResult = ADC_GetResult16(0uL) - targResult;
            if (curResult < 0)
            {
                curResult *= -1;
            }
            if (curResult < bestResult)
            {
                bestResult = curResult;
                bestTrim = curTrim;
            }
        }
        
        /* Set the best trim. */
        CY_SET_REG32(CYREG_UAB0_OA_TRIM0, 
            CY_GET_REG32(CYREG_UAB0_OA_TRIM0) & ~(0xfuL << CyUAB_OA_OFFSET_SHIFT));
        CY_SET_REG32(CYREG_UAB0_OA_TRIM0, 
            CY_GET_REG32(CYREG_UAB0_OA_TRIM0) | (bestTrim << CyUAB_OA_OFFSET_SHIFT));
        
        /* Clear the modbit */
        ADC_UABH_A_CAP_ABCF_VAL_REG &= ~(0x1uL << CyUAB_SIGN_VAL_SHIFT);
        ADC_UABH_B_CAP_ABCF_VAL_REG &= ~(0x1uL << CyUAB_SIGN_VAL_SHIFT);
    }
#endif /* ADC_ANY_CONFIG_USES_FILTER != 0u */
/* ****************************************************************************
* Function Name: ADC_Init
****************************************************************************//*
*
* \brief Initialize the component according to parameters defined in the 
* customizer.
*
* \param None
* 
* \return None
*
* \sideeffect None
*
* <b>Code Snippet</b>
*  \snippet main.c snippet_ADC_Init
*
*******************************************************************************/
void ADC_Init(void)
{
	uint32 chNum = 0ul;
	uint32 configNum = 0u;
	int32 counts;
	
	if(0u == ADC_initVar)
	{
		/* Set offset and countsPer10Volt for all channels */
		for(chNum = 0ul; chNum < ADC_TOTAL_CHANNELS_NUM; chNum++)
		{      
			if((ADC_channelsConfig[chNum] & ADC_SAR_CHAN_CONFIG_RESOLUTION_MSK) != 0u)
        	{
				if((ADC_allConfigs[configNum].sampleCtrl 
					& ADC_SAR_SAMPLE_CTRL_SUB_RESOLUTION_MSK) 
					== ADC_SUB_RESOLUTION_10B)
				{
					counts = (int32) ADC_SAR_WRK_MAX_10BIT;
				}
				else
				{
					counts = (int32) ADC_SAR_WRK_MAX_8BIT;
				}
        	}
        	else
        	{
               counts = (int32)ADC_SAR_WRK_MAX_12BIT;
        	}
			
			/* Single Ended Channel */
			if((ADC_channelsConfig[chNum] & ADC_SAR_CHAN_CONFIG_DIFFERENTIAL_EN_MSK) == 0u)
        	{
				if(((ADC_allConfigs[configNum].sampleCtrl 
					& ADC_SAR_SAMPLE_CTRL_SINGLE_ENDED_SIGNED_MSK) 
					== ADC_SAR_SAMPLE_CTRL_SINGLE_ENDED_SIGNED_MSK) && 
					((ADC_allConfigs[configNum].ctrl & ADC_SAR_CTRL_NEG_SEL_MSK) 
					== ADC_NEG_VREF_SHIFTED))
				{
					/* Set offset to the minus half scale to convert results to unsigned format */
                	ADC_offset[chNum] = (int16)(counts / -2);		
            	}
				else
				{
                	ADC_offset[chNum] = 0;	
				}
			}
			else    /* Differential channel */
        	{
               	ADC_offset[chNum] = 0; 
			}
            
			/* Calculate gain in counts per 10 volts with rounding */
        	ADC_countsPer10Volt[chNum] = (int16)(((counts * ADC_10MV_COUNTS) \
                            + ADC_allConfigs[configNum].vrefMvValue) \
							/ (ADC_allConfigs[configNum].vrefMvValue * 2));
            
            /* Increment configuration number after rolling over to the next configuration*/
			if((ADC_allConfigs[configNum].channelBase
				+ ADC_allConfigs[configNum].numChannels) == chNum)
			{
				configNum++;
			}
		} /* for(chNum = 0ul; chNum < ADC_TOTAL_CHANNELS_NUM; chNum++) */
        
        #if(ADC_IRQ_REMOVE == 0u)
            /* Start and set interrupt vector */
            CyIntSetPriority(ADC_INTC_NUMBER, ADC_INTC_PRIOR_NUMBER);
            (void)CyIntSetVector(ADC_INTC_NUMBER, &ADC_ISR);
        #endif   /* End ADC_IRQ_REMOVE */
        
        /* Initialize the channel enable masks for each configuration */
        for(configNum=0u; configNum < ADC_TOTAL_CONFIGS; configNum++)
		{
			ADC_channelEnMasks[configNum] = ADC_allConfigs[configNum].chanEn;
		}
        
        #if(0u != ADC_ANY_CONFIG_USES_FILTER)		
		    /* Configure the common filter settings if any configuration filters */
		    ADC_UABH_A_Init(&ADC_UABH_A_FILTER_config);
		    ADC_UABH_B_Init(&ADC_UABH_B_FILTER_config);
            ADC_FILTERAGND2SAR_BUFFER_Init();
            /* Set several of the UAB switches or buffers based on what source is used as Vagnd/Vref. */
            #if ADC_UABH_A_halfuab__VAGND_SRC != ADC_UABH_A_halfuab__SRC_AGNDBUF
                ADC_UABH_A_SetStaticSwitch(ADC_SW_EXTAGND, CyUAB_SW_CLOSED);
            #else
                ADC_UABH_A_SetAgndPower(CyUAB_PWR_HIGH);
            #endif
            
            /* Control UAB filter output switch with PHI3 "11" (always closed). */
            ADC_UABH_B_SRAM0_REG |= 0x4u;
            ADC_UABH_B_SRAM1_REG |= 0x4u;
            ADC_UABH_B_SetSwitch(CyUAB_SW_PO, CyUAB_CLK_PHI3);
        #endif /* ADC_ANY_CONFIG_USES_FILTER != 0u */
        
        /* Initialize configuration zero if SelectConfig has not been called */
        if(0u == ADC_selected)
	    {
            ADC_selected = 1u;
            configNum = 0u;
            /* Change Vref selection if is was routed by Creator */
            #if (ADC_VREF_ROUTED)
            ADC_vrefAMux_Select((uint8)configNum);
            #endif
            ADC_InitConfig(&ADC_allConfigs[configNum]);
            ADC_SAR_CHAN_EN_REG = ADC_channelEnMasks[configNum];
            #if(0u != ADC_ANY_CONFIG_USES_FILTER)	
                ADC_filterVinMux_Select((uint8)configNum);
            #endif
        }           
	}
    return;
}

/* ****************************************************************************
* Function Name: ADC_Enable
****************************************************************************//*
*
* \brief Enables the component. 
*
* \param None
* 
* \return None
* 
* \sideeffect
*  None
*
* <b>Code Snippet</b>
*  \snippet main.c snippet_ADC_Enable
*
*******************************************************************************/
void ADC_Enable(void) 
{

    #if(0u != ADC_ANY_CONFIG_USES_FILTER)	
    	if((ADC_allConfigs[ADC_currentConfig].miscConfig
    		& ADC_MISC_CONFIG_FILTER_PRESENT_MSK)
    		== ADC_MISC_CONFIG_FILTER_PRESENT_MSK)
    	{
            ADC_FILTERAGND2SAR_BUFFER_Enable();
    		ADC_UABH_A_Enable();
    		ADC_UABH_B_Enable();
            ADC_UABH_A_SetModbitSource(31u, 31u);
            ADC_UABH_B_SetModbitSource(31u, 31u);
            ADC_UABH_A_SetStartupDelay(ADC_allConfigs[ADC_currentConfig].filterStartDelay);
            ADC_UABH_B_SetStartupDelay(ADC_allConfigs[ADC_currentConfig].filterStartDelay);
            ADC_UABH_B_Run(1u);
            ADC_UABH_A_Run(1u);
    	}
    #endif /* ADC_ANY_CONFIG_USES_FILTER != 0u */
        
    if (0u == (ADC_SAR_CTRL_REG & ADC_SAR_CTRL_ENABLED_MSK))
    {
        while (0u != (ADC_SAR_STATUS_REG & ADC_BUSY_MSK))
        {
            /* wait for SAR to go idle to avoid deadlock */
        }
        
        ADC_SAR_CTRL_REG |= ADC_SAR_CTRL_ENABLED_MSK;
        
        /* The block is ready to use 10 us after the enable signal is set high. */
        CyDelayUs(ADC_10US_DELAY);
    }
    return;
}


/* [] END OF FILE */
